## 计算机世界的基石：从逻辑门说起
### 计算机系统底层逻辑
 **hello world**
1. **信息**
 hello.c
 - 大部分的现代计算机系统都使用ASCII标准来表示文本字符。
 - hello. c程序是以字节序列的方式储存在文件中的。每个字节都有一个整数值，对应于某些字符。例如，第一个字节的整数值是35，它对应的就是字符“#”。第二个字节的整数值为105，它对应的字符是‘i’，依此类推。注意，每个文本行都是以一个看不见的换行符‘\n’来结束的，它所对应的整数值为10。像hello. c这样只由ASCII字符构成的文件称为文本文件，所有其他文件都称为二进制文件。
2. **编译系统**
- 为了在系统上运行hello.c程序，每条c语句都必须被其他程序转化为一系列的低级机器语言指令。然后这些指令按照一种称为可执行目标程序的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也称为可执行目标文件。
- 在Unix系统上，从源文件到目标文件的转化是由编译器驱动程序完成的：
  ```
  linux>gcc -0 hello hello.c
  ```
- 此处GCC编译器驱动程序读取源程序文件hello.c，并将其翻译成一个可执行的目标文件hello。这个过程可分为四个阶段：
    1. 预处理阶段
     - 预处理器(cpp)根据以字符#开头的命令，修改原始的C程序。比如hello. c中第1行的# include < stdio. h> 命令告诉预处理器读取系统头文件stdio. h的内容，并把它直接插入程序文本中。结果就得到了另一个C程序，通常是以. i作为文件扩展名。
   ```
   gcc -E hello.c -o hello.i
   ```
    2. 编译阶段
     - 编译器(cc1)将文本文件hello. i翻译成文本文件hello. s,它包含一个汇编语言程序。
  ```
  gcc -S hello.i -o hello.s
  ```
    3. 汇编阶段
     - 接下来，汇编器(as)将hello. s翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序(relocatable object program)的格式，并将结果保存在目标文件hello. o中。hello. o文件是一个二进制文件，它包含的17个字节是函数main的指令编码。如果我们在文本编辑器中打开hello. o文件，将看到一堆乱码。
  ```
  gcc -c hello.s -o hello.o 
  ```
    4. 链接阶段
     - hello程序调用了printf函数，它是每个C编译器都提供的标准C库中的一个函数。printf函数存在于一个名为printf. o的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的hello. o程序中。链接器(ld)就负责处理这种合并。结果就得到hello文件，它是一个可执行目标文件（或者简称为可执行文件），可以被加载到内存中，由系统执行。
  ```
  gcc hello.c -o hello
  ```
    - 运行
  ```
  ./hello
  ```


3. **处理器**
 - 经过编译系统，现在hello.c源程序已经被编译系统翻译成了可执行目标文件，我们将它的文件名输入到称为shell的应用程序中：
  ```
  linux> ./hello
  hello，world
  linux>
  ```
  如果该命令行的第一个单词不是一个内置的shell命令，那么shell就会假设这是一个可执行文件的名字，它将加载并运行这个文件。所以在此例中，shell将加载并运行hello程序，然后等待程序终止。hello程序在屏幕上输出它的消息，然后终止。shell随后输出一个提示符，等待下一个输入的命令行。

4. **系统的硬件组成**
 为了理解运行hello程序时发生了什么，我们需要了解一个典型系统的硬件组织，
   - 总线
   - I/O设备
   - 主存
   - 处理器
  （运行hello）
  前面简单描述了系统的硬件组成和操作，现在开始介绍当我们运行示例程序时到底发生了些什么。

5. **高速缓存至关重要**
   - 数据复制开销大：程序运行需多次将数据/指令从低速存储（如磁盘）复制到高速存储（如寄存器），例如hello程序需从磁盘→内存→CPU→显示设备，这些复制操作降低了程序效率。
   - 储存设备特点是容量与速度成反比：容量大的设备（如磁盘）速度慢，速度快的小容量设备（如寄存器）成本高昂。
   - 通过空间换时间，用快速小容量缓存层预测并存储热点数据，将平均数据访问延迟逼近最快缓存层级，而非最慢的主存/磁盘。
  
6. **存储设备形成层次结构**
   - 存储器层次结构的主要思想是上一层的存储器作为第一层存储器的高速缓存。

7. **操作系统管理硬件**
   当shell加载和运行hello程序时，以及hello程序输出自己的消息时，shell和hello程序都没有直接访问硬盘、显示器、磁盘或者主存。我们可以把操作系统看成时应用程序和硬件之间插入的以曾软件，所有应用程序对硬件的操作尝试都必须通过操作系统。

8. **进程**
   示例场景中有两个并发的进程：shell进程和hello进程。最开始，只有shell进程在运行，即等待命令行上的输入。当我们让它运行hello程序时，shell通过调用一个专门的函数，即系统调用，来执行我们的请求，系统调用会将控制权传递给操作系统。操作系统保存shell进程的上下文，创建一个新的hello进程及其上下文，然后将控制权传给新的hello进程.hello进程终止后，操作系统恢复shell进程的上下文，并将控制权传回给它，shell进程会继续等待下一个命令行输入。
   - 上下文切换-->控制权传递到新进程-->从新进程上次停止的位置开始
   
9. **线程**
   - 在现代系统中，一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享代码和全局数据。
  由于网络服务器对并行处理的需求，线程成为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据以及线程一般都比进程更高效，当存在多处理器的用的环境时，多线程也是一种使得程序可以运行得更快的方法。
  
10. **虚拟内存**
   - 虚拟内存是一个抽象概念，它为每一个进程提供了一种假象，即每个进程都在独占使用主存，看到的内存一致，称为虚拟地址空间。
   - 用图书馆打个比方：

     - 程序代码和数据：固定的教科书，位置不变，打开就能用。（存储程序指令和全局/静态变量，由可执行文件直接初始化，位置固定）
     
     - 堆：自由摆放的笔记本，可以随时增删（比如 malloc 申请内存，动态分配内存，手动管理或由自动管理，大小可变）。

     - 栈：临时便签纸，记录函数调用的步骤，用完自动清理。（函数调用的上下文，自动管理，动态收缩膨胀）

     - 共享库：公共工具书（比如 print 函数），多个程序一起用，但只存一份。（多个进程共享的库代码和数据，动态链接）

     - 内核内存：馆长的密室，普通读者（用户程序）进不去。（保护内核代码和数据，用户程序无法直接访问）

程序看不到的部分（比如 print 的实现），就像书里的内容被封装好了，你只管翻页，不用管书是怎么印的。这样一来，程序既能安全运行，又能高效共享资源，内存不够时还能“借用”硬盘空间当临时仓库（交换空间）。

11. **系统之间利用网络通讯**
    - 回到hello示例，我们可以使用熟悉的telnet应用在一个远程主机上运行hello程序。假设用本地主机上的telnet客户端连接远程主机上的telnet服务器。在我们登录到远程主机并运行shell后，远端的shell就在等待接收输入命令。
    - 当我们在telnet客户端键入“hello”字符串并敲下回车键后，客户端软件就会将这个字符串发送到telnet的服务器。telnet服务器从网络上接收到这个字符串后，会把它传递给远端shell程序。接下来，远端shell运行hello程序，并将输出行返回给telnet服务器。最后，telnet服务器通过网络把输出串转发给telnet客户端，客户端就将输出串输出到我们的本地终端上。

12. **小结**
- 计算机系统是由硬件和系统软件组成的，它们共同协作以运行应用程序。计算机内部的信息被表示为一组组的位，它们依据上下文有不同的解释方式。程序被其他程序翻译成不同的形式，开始时是ASCⅡ文本，然后被编译器和链接器翻译成二进制可执行文件。
处理器读取并解释存放在主存里的二进制指令。因为计算机花费了大量的时间在内存、I/O设备和CPU寄存器之间复制数据，所以将系统中的存储设备划分成层次结构———CPU寄存器在顶部，接着是多层的硬件高速缓存存储器、DRAM主存和磁盘存储器。在层次模型中，位于更高层的存储设备比低层的存储设备要更快，单位比特造价也更高。层次结构中较高层次的存储设备可以作为较低层次设备的高速缓存。通过理解和运用这种存储层次结构的知识，程序员可以优化C程序的性能。
操作系统内核是应用程序和硬件之间的媒介。它提供三个基本的抽象：1）文件是对I/O设备的抽象；2）虚拟内存是对主存和磁盘的抽象；3）进程是处理器、主存和I/O设备的抽象。
最后，网络提供了计算机系统之间通信的手段。从特殊系统的角度来看，网络就是一种I/O设备。